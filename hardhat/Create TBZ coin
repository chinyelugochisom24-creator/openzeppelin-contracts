// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract TBillionz is ERC20, Ownable {
    uint256 public constant TOTAL_SUPPLY = 1_000_000_000_000 * 10**18; // 1 Trillion with 18 decimals
    uint256 public constant MAX_WALLET = TOTAL_SUPPLY / 100; // 1%
    uint256 public transactionTax = 200; // 2% (basis points)
    
    address public dreamFund;
    
    constructor(address _dreamFund) ERC20("T~Billionz", "TBZ") {
        dreamFund = _dreamFund;
        _mint(msg.sender, TOTAL_SUPPLY);
    }
    
    function transfer(address to, uint256 amount) public override returns (bool) {
        require(balanceOf(msg.sender) <= MAX_WALLET, "Wallet exceeds max");
        require(balanceOf(to) + amount <= MAX_WALLET, "Recipient exceeds max");
        
        uint256 tax = (amount * transactionTax) / 10000;
        uint256 burnAmount = tax / 2; // 1% burn
        uint256 liqAmount = tax / 4; // 0.5% liquidity
        uint256 fundAmount = tax - burnAmount - liqAmount; // 0.5% fund
        
        _burn(msg.sender, burnAmount);
        super.transfer(dreamFund, fundAmount);
        // Liquidity logic would go here (e.g., to Uniswap)
        
        return super.transfer(to, amount - tax);
    }
    
    // Owner functions: Update tax, etc.
    function setDreamFund(address _newFund) external onlyOwner {
        dreamFund = _newFund;
    }
}
